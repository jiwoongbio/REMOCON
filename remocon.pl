#!/bin/env perl
# Author: Jiwoong Kim (jiwoongbio@gmail.com)
use strict;
use warnings;
local $SIG{__WARN__} = sub { die $_[0] };

use List::Util qw(sum);
use Getopt::Long qw(:config no_ignore_case);

GetOptions('h' => \(my $help = ''),
	'n' => \(my $namesort = ''),
	's' => \(my $strict = ''),
	'a' => \(my $useAS = ''),
);
if($help || scalar(@ARGV) == 0) {
	die <<EOF;

Usage:   perl remocon.pl input.sam input.contaminant.sam > output.contaminant_removed.sam

Options: -h       display this help message
         -n       input SAM files sorted lexicographically by query name
         -s       remove ambiguous reads
         -a       use AS, alignment score generated by aligner

EOF
}

my ($samFile, $samFileContaminant) = @ARGV;
system("samtools view -H $samFile");
open(my $reader,            "samtools view $samFile |");
open(my $readerContaminant, "samtools view $samFileContaminant |");
my %numberHash = ();
$numberHash{$_} = 0 foreach('contaminant', 'non-contaminant', 'ambiguous');
my ($readName, @tokenListList) = ('');
my $lineContaminant = <$readerContaminant>;
while(my $line = <$reader>) {
	chomp($line);
	my @tokenList = split(/\t/, $line);
	if($tokenList[0] ne $readName) {
		printLines() if(scalar(@tokenListList) > 0);
		($readName, @tokenListList) = ($tokenList[0]);
	}
	push(@tokenListList, \@tokenList);
}
printLines() if(scalar(@tokenListList) > 0);
close($reader);
close($readerContaminant);
print STDERR "$_: $numberHash{$_}\n" foreach('contaminant', 'non-contaminant', 'ambiguous');

sub printLines {
	my %tokenListHash            = map {($_->[1] & 192) / 64 => $_} grep {!($_->[1] & 2304)} @tokenListList;
	my %tokenListHashContaminant = map {($_->[1] & 192) / 64 => $_} grep {!($_->[1] & 2304)} getTokenListListContaminant($readName);
	my @indexList = sort {$a <=> $b} keys %tokenListHash;
	my $alignmentScore            = sum(0, map {getAlignmentScore(@$_)} grep {!($_->[1] & 4)} grep {defined($_)} @tokenListHash{@indexList});
	my $alignmentScoreContaminant = sum(0, map {getAlignmentScore(@$_)} grep {!($_->[1] & 4)} grep {defined($_)} @tokenListHashContaminant{@indexList});
	if($alignmentScoreContaminant > $alignmentScore) {
		$numberHash{'contaminant'} += 1;
	} elsif($alignmentScore > $alignmentScoreContaminant) {
		print map {join("\t", @$_), "\n"} @tokenListList;
		$numberHash{'non-contaminant'} += 1;
	} else {
		print map {join("\t", @$_), "\n"} @tokenListList if($strict eq '');
		$numberHash{'ambiguous'} += 1;
	}
}

sub getTokenListListContaminant {
	my ($readName) = @_;
	my @tokenListListContaminant = ();
	for(; $lineContaminant; $lineContaminant = <$readerContaminant>) {
		chomp($lineContaminant);
		my @tokenList = split(/\t/, $lineContaminant);
		next if($tokenList[0] lt $readName and $namesort);
		last if($tokenList[0] ne $readName);
		push(@tokenListListContaminant, \@tokenList);
	}
	return @tokenListListContaminant;
}

sub getAlignmentScore {
	my @tokenList = @_;
	my %tokenHash = ();
	(@tokenHash{'qname', 'flag', 'rname', 'pos', 'mapq', 'cigar', 'rnext', 'pnext', 'tlen', 'seq', 'qual'}, my @tagTypeValueList) = @tokenList;
	$tokenHash{"$_->[0]:$_->[1]"} = $_->[2] foreach(map {[split(/:/, $_, 3)]} @tagTypeValueList);
	if($useAS) {
		return $tokenHash{'AS:i'} if(defined($tokenHash{'AS:i'}));
		return 0;
	}
	return $tokenHash{'Za:f'} if(defined($tokenHash{'Za:f'}));
	return $tokenHash{'AS:i'} if(defined($tokenHash{'AS:i'}));
	return 0;
}
